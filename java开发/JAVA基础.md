

[TOC]

### 父类有一个公有方法，私有方法，静态方法，公有方法能否重写，私有能否重写，静态方法能否重写，为什么私有不能，为什么静态方法不能？

答：公有方法可以被重写，私有和静态方法不能被重写。因为因为*私有方法*的访问范围仅限于类,我们无法在类之外访问它们，子类也不行。静态方法可以被继承，但是不能被重写。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：**父类名.静态方法**调用隐藏的静态方法。换句话说，**父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性**

### Java重写的规定

- 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

- 字类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符（字类不能重写父类被声明为private权限的方法）

- 返回值类型：

  父类是void，子类只能是void

  父类是A类型，子类是A类型或者A类型的子类

  父类是基本数据类型（如double），子类返回值类型必须相同

- 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类

### Java重载

同一个类中同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**。

### 重载和重写的区别

​	方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。

### Java中的String类能否被继承？为什么？

不能

```Java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    // 省略...　
}
```

### Java多态

多态是同一个行为具有多个不同表现形式或形态的能力。

多态就是同一个接口，使用不同的实例而执行不同操作

### 多态的优点

- \1. 消除类型之间的耦合关系
- \2. 可替换性
- \3. 可扩充性
- \4. 接口性
- \5. 灵活性
- \6. 简化性

### 多态存在的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

### 为什么Java中有些接口没有任何方法？RandomAccess 接口有什么作用？

Java中没有声明任何方法的接口被称为==标识接口==，标识接口对于实现它的类没有任何语义上的要求，它仅仅充当一个标识的作用，用来表示实现它的类属于一个特定的类型。Java中已经存在的标识接口有Cloneable/Serializable。在使用时通常会用 `instance of` 来判断实例对象的类型是否实现了一个给定的标识接口。

**RandomAccess 接口有什么作用**:

RandomAccess 用来当标记的，是一种标记接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法

### 泛型是什么？泛型有什么作用？为什么引入泛型

泛型的本质是==参数化类型==，也就是说所操作的数据类型被指定为一个参数

引入泛型是为了==更好的重用代码==。泛型之前使用 Object 来实现通用、不同类型的处理，但缺点在于需要强制转换以及无法在编译时确定类型转换是否正常，到运行时才确定，不安全。

所以引入泛型的目的：在能够重用代码的同时

- 类型安全

>泛型的主要目标是提高 Java 程序的类型安全
>编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常
>符合越早出错代价越小原则

- 消除强制类型转换

>泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换
>所得即所需，这使得代码更加可读，并且减少了出错机会

- 潜在的性能收益

>由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改
>所有工作都在编译器中完成
>编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已

### 泛型的使用方式

+ 泛型类：实例化类的对象时才能确定的类型，其定义如 `class Test<T> {}`
+ 泛型接口：泛型接口与泛型类一样，其定义譬如`interface Generator<E>{ E dunc(E e);}`
+ 泛型方法：泛型方法所在的类可以是泛型类也可以是非泛型类，是否拥有泛型方法与所在的类无关。如`<T> void func(T val) {}`，只有在方法前加入`<T>`才是泛型方法

### 泛型是如何实现的？什么是类型擦除？

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有泛型类型相关的信息，所以在运行时不存在任何泛型类型相关的信息，譬如 `List<Integer>` 在运行时仅用一个 List 来表示，这样做的目的是为了和 Java 1.5 之前版本进行兼容

**类型擦除**：

当编译器对带有泛型的java代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这在就叫做 类型擦除（type erasure）。

泛型擦除具体来说就是在编译成字节码时首先进行类型检查和类型推断，接着进行类型擦除（即所有类型参数都用他们的限定类型替换，包括类、变量和方法），接着如果类型擦除和多态性发生冲突时就在子类中生成桥方法解决，接着如果调用泛型方法的返回类型被擦除则在调用该方法时插入强制类型转换

**泛型的所有动作都发生在边界处：对传入的值进行额外的编译期检查，对传出的值进行强制类型转换。**

### 可以把`List<String>`传递给一个接受`List<Object>`参数的方法吗

不能

原因是泛型的不可变性，不可变性指不论 A B 有什么关系，A 的容器和 B 的容器都没有父子关系。也就是说`List<String>`并不是`List<Object>`子类，所以不能传递。

注意`List<Object>`是可以存储String对象

**补充**:

泛型的这种情况称为 不可变性，与之对应的概念是 协变、逆变：

- 协变：如果 A 是 B 的父类，并且 A 的容器（比如 List< A>） 也是 B 的容器（List< B>）的父类，则称之为协变的（父子关系保持一致）
- 逆变：如果 A 是 B 的父类，但是 A 的容器 是 B 的容器的子类，则称之为逆变（放入容器就篡位了）
- 不可变：不论 A B 有什么关系，A 的容器和 B 的容器都没有父子关系，称之为不可变

Java 中数组是协变的，也就是A是B的子类，则`A[]`也是`B[]`的子类

### 泛型中的通配符

通配符是为了解决泛型的不变性，也就是`List<Object> t=new List<String>()`这种写法是非法的情况

通配符的泛型通常用来作为方法的参数

 **无限制通配符<?>**
 ? 和 Object 不一样，`List<?>`表示未知类型的列表，当方法参数为 `List<?>` 时可以传入`List<String>`;`List<Object>` 表示任意类型的列表，当方法参数为 `List<Object>` 时==不可以==传入`List<String>`，

 **上界通配符<? extends T>**
在类型参数中使用 extends 表示这个泛型中的参数必须是 T 或者 T 的子类，
`<? extends T>` 用于==灵活读取==，使得方法可以读取 T 或 T 的任意子类型的容器对象。

 **下界通配符<? super T>**
在类型参数中使用 super 表示这个泛型中的参数必须是 T 或者 T 的父类。
`<? super T>` 用于==灵活写入或比较==，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象。

因此使用通配符的基本原则：

- 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;(T 的子类) **T 的生产者的意思就是结果会返回 T，这就要求返回一个具体的类型，必须有上限才够具体**

- 如果它表示一个 T 的消费者，就使用 < ? super T>；（T 的父类）**T 的消费者的意思是要操作 T，这就要求操作的容器要够大，所以容器需要是 T 的父类，即 super T**

- 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。

使用通配符会使得类型未知，所以很多操作不被允许

### Spring 中的反射

1 创建Bean实例时用到了反射

2 构造方法依赖注入时的反射

3 setter方法依赖注入时的反射

4 @Autowired依赖注入时的反射

