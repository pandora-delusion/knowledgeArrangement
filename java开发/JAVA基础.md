

[TOC]

### JRE和JDK的区别

**RE(Java Runtime Enviroment)****是Java的运行环境**。面向Java程序的使用者，而不是开发者。如果你仅下载并安装了JRE，那么你的系统只能运行Java程序。JRE是运行Java程序所必须环境的集合，包含JVM标准实现及 Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。它不包含开发工具(编译器、调试器等)。

**JDK(Java Development Kit)**又称J2SDK(Java2 Software Development Kit)，是Java开发工具包，它提供了Java的开发环境(提供了编译器javac等工具，用于将java文件编译为class文件)和运行环境(提 供了JVM和Runtime辅助包，用于解析class文件使其得到运行)。如果你下载并安装了JDK，那么你不仅可以开发Java程序，也同时拥有了运 行Java程序的平台。JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。

总之JDK包含JRE，JRE包含JVM

### 父类有一个公有方法，私有方法，静态方法，公有方法能否重写，私有能否重写，静态方法能否重写，为什么私有不能，为什么静态方法不能？

答：公有方法可以被重写，私有和静态方法不能被重写。因为因为*私有方法*的访问范围仅限于类,我们无法在类之外访问它们，子类也不行。静态方法可以被继承，但是不能被重写。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：**父类名.静态方法**调用隐藏的静态方法。换句话说，**父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性**

### Java重写的规定

- 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

- 字类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符（字类不能重写父类被声明为private权限的方法）

- 返回值类型：

  父类是void，子类只能是void

  父类是A类型，子类是A类型或者A类型的子类

  父类是基本数据类型（如double），子类返回值类型必须相同

- 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类

### Java重载

同一个类中同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**。

### 重载和重写的区别

​	方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。

### Java中的String类能否被继承？为什么？

不能

```Java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    // 省略...　
}
```

### Java多态

多态是同一个行为具有多个不同表现形式或形态的能力。

多态就是同一个接口，使用不同的实例而执行不同操作

### 多态的优点

- \1. 消除类型之间的耦合关系
- \2. 可替换性
- \3. 可扩充性
- \4. 接口性
- \5. 灵活性
- \6. 简化性

### 多态存在的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

### 为什么Java中有些接口没有任何方法？RandomAccess 接口有什么作用？

Java中没有声明任何方法的接口被称为==标识接口==，标识接口对于实现它的类没有任何语义上的要求，它仅仅充当一个标识的作用，用来表示实现它的类属于一个特定的类型。Java中已经存在的标识接口有Cloneable/Serializable。在使用时通常会用 `instance of` 来判断实例对象的类型是否实现了一个给定的标识接口。

**RandomAccess 接口有什么作用**:

RandomAccess 用来当标记的，是一种标记接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法

### 泛型是什么？泛型有什么作用？为什么引入泛型

泛型的本质是==参数化类型==，也就是说所操作的数据类型被指定为一个参数

引入泛型是为了==更好的重用代码==。泛型之前使用 Object 来实现通用、不同类型的处理，但缺点在于需要强制转换以及无法在编译时确定类型转换是否正常，到运行时才确定，不安全。

所以引入泛型的目的：在能够重用代码的同时

- 类型安全

>泛型的主要目标是提高 Java 程序的类型安全
>编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常
>符合越早出错代价越小原则

- 消除强制类型转换

>泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换
>所得即所需，这使得代码更加可读，并且减少了出错机会

- 潜在的性能收益

>由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改
>所有工作都在编译器中完成
>编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已

### 泛型的使用方式

+ 泛型类：实例化类的对象时才能确定的类型，其定义如 `class Test<T> {}`
+ 泛型接口：泛型接口与泛型类一样，其定义譬如`interface Generator<E>{ E dunc(E e);}`
+ 泛型方法：泛型方法所在的类可以是泛型类也可以是非泛型类，是否拥有泛型方法与所在的类无关。如`<T> void func(T val) {}`，只有在方法前加入`<T>`才是泛型方法

### 泛型是如何实现的？什么是类型擦除？

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有泛型类型相关的信息，所以在运行时不存在任何泛型类型相关的信息，譬如 `List<Integer>` 在运行时仅用一个 List 来表示，这样做的目的是为了和 Java 1.5 之前版本进行兼容

**类型擦除**：

当编译器对带有泛型的java代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这在就叫做 类型擦除（type erasure）。

泛型擦除具体来说就是在编译成字节码时首先进行类型检查和类型推断，接着进行类型擦除（即所有类型参数都用他们的限定类型替换，包括类、变量和方法），接着如果类型擦除和多态性发生冲突时就在子类中生成桥方法解决，接着如果调用泛型方法的返回类型被擦除则在调用该方法时插入强制类型转换

**泛型的所有动作都发生在边界处：对传入的值进行额外的编译期检查，对传出的值进行强制类型转换。**

### 可以把`List<String>`传递给一个接受`List<Object>`参数的方法吗

不能

原因是泛型的不可变性，不可变性指不论 A B 有什么关系，A 的容器和 B 的容器都没有父子关系。也就是说`List<String>`并不是`List<Object>`子类，所以不能传递。

注意`List<Object>`是可以存储String对象

**补充**:

泛型的这种情况称为 不可变性，与之对应的概念是 协变、逆变：

- 协变：如果 A 是 B 的父类，并且 A 的容器（比如 List< A>） 也是 B 的容器（List< B>）的父类，则称之为协变的（父子关系保持一致）
- 逆变：如果 A 是 B 的父类，但是 A 的容器 是 B 的容器的子类，则称之为逆变（放入容器就篡位了）
- 不可变：不论 A B 有什么关系，A 的容器和 B 的容器都没有父子关系，称之为不可变

Java 中数组是协变的，也就是A是B的子类，则`A[]`也是`B[]`的子类

### 泛型中的通配符

通配符是为了解决泛型的不变性，也就是`List<Object> t=new List<String>()`这种写法是非法的情况

通配符的泛型通常用来作为方法的参数

 **无限制通配符<?>**
 ? 和 Object 不一样，`List<?>`表示未知类型的列表，当方法参数为 `List<?>` 时可以传入`List<String>`;`List<Object>` 表示任意类型的列表，当方法参数为 `List<Object>` 时==不可以==传入`List<String>`，

 **上界通配符<? extends T>**
在类型参数中使用 extends 表示这个泛型中的参数必须是 T 或者 T 的子类，
`<? extends T>` 用于==灵活读取==，使得方法可以读取 T 或 T 的任意子类型的容器对象。

 **下界通配符<? super T>**
在类型参数中使用 super 表示这个泛型中的参数必须是 T 或者 T 的父类。
`<? super T>` 用于==灵活写入或比较==，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象。

因此使用通配符的基本原则：

- 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;(T 的子类) **T 的生产者的意思就是结果会返回 T，这就要求返回一个具体的类型，必须有上限才够具体**

- 如果它表示一个 T 的消费者，就使用 < ? super T>；（T 的父类）**T 的消费者的意思是要操作 T，这就要求操作的容器要够大，所以容器需要是 T 的父类，即 super T**

- 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。

使用通配符会使得类型未知，所以很多操作不被允许

### Java反射

**[JAVA反射机制](https://baike.baidu.com/item/JAVA反射机制/6015990)是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。**

| 类名          | 用途                                             |
| ------------- | ------------------------------------------------ |
| Class类       | 代表类的实体，在运行的Java应用程序中表示类和接口 |
| Field类       | 代表类的成员变量（成员变量也称为类的属性）       |
| Method类      | 代表类的方法                                     |
| Constructor类 | 代表类的构造方法                                 |

### Spring 中的反射

1 创建Bean实例时用到了反射

2 构造方法依赖注入时的反射

3 setter方法依赖注入时的反射

4 @Autowired依赖注入时的反射

### final关键字的功能

#### 修饰字段

1.  如果引用为基本数据类型，则该引用为常量，该值无法修改；
2.  如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
3.  如果引用时类的成员变量，则必须当场赋值，否则编译会报错。

#### 修饰方法

当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。

#### 修饰类

当用final修改类时，该类成为最终类，无法被继承

### String、StringBuffer和StringBuilder

String是final修饰，对象是不可变对象，每次操作会产生一个新的对象；StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder；

StringBuffer具有线程安全性，所有公开方法都是synchronized修饰过的

在使用场景上，并发必选StringBuffer，迭代必选StringBuilder，普通场景选String，避免不必要的类型转换开销

### 链表和数组的插入删除时间复杂度都是o(n)，为什么链表效率高

因为这个O(n)内涵不同，分别是写O(n)和读O(n)。
数组擅长读取，链表擅长写入。
写入要先读取定位，再写入。
读取场景：任意序位读取，复杂度： 数组O(1)，链表O(n)。
写入场景：任意序位写入，定位复杂度：数组O(1)，链表O(n)；写入复杂度：数组O(n)，链表O(1)。
在写入场景中，数组链表的复杂度是定位写入复杂度之和，都是O(n),但写入比定位的O(n)慢很多，所以两个表面看起来一样的O(n)的实际时间还是差很多。
所以说链表和数组的插入删除时间复杂度都是o(n)，链表写入效率高。

### 守护线程

在操作系统里面是没有所谓的守护线程的概念的，只有守护进程一说。但是Java语言机制是构建在JVM的基础之上的，所以受用户线程也是构建在JVM平台之上的。

所谓的守护线程，指的是程序运行时在后台提供的一种通用服务的线程。比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

User Thread（用户线程）和Daemon Thread（守护线程）从本质上来说并没有什么区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。

```Java
// 将普通线程设为守护线程
public final void setDaemon(boolean on);
```

1. thread.setDaemon(true)必须在thread.start()之前设置，否则会抛出一个IllegalThreadStateException异常。
2. 在Daemon线程中产生的新线程也是Daemon的
3. 不是所有的应用都可以分配给Daemon线程来进行服务的，比如读写操作或者计算逻辑

#### 守护线程的应用场景

​	Web服务器中的Servlet，在容器启动时，后台都会初始化一个服务线程，即调度线程，负责处理http请求，然后每个请求过来，调度线程就会从线程池中取出一个工作者线程来处理该请求，从而实现并发控制的目的。也就是说，一个实际应用在Java的线程池中的调度线程。

### ArrayList的toArray实现

```Java
public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}

public <T> T[] toArray(T[] a) {
    if (a.length < size)
        // 如果a的长度小于源数组大小，则创建新数组
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    // 否则就地拷贝，多余的部分用null填充
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}

// Arrays.copyOf
public static <T> T[] copyOf(T[] original, int newLength) {
    return (T[]) copyOf(original, newLength, original.getClass);
}

// Arrays.copyOf
public static <T, U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    // class对象也可以类型转换，数组是协变的，注意！
    // 如果newType是Object[],创建Object的数组，否则
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        // getComponentType获得数组的Class对象，然后用newInstance创建新的数组对象
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    // 完成数组的拷贝
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;   
}

```

