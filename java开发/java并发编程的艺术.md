[TOC]

### JVM发生OOM的四种情况

1. Java堆溢出
2. 栈溢出（如果请求栈的深度不足时抛出的错误会抛出java.lang.StackOverflowError，如果申请创建的线程比较多超过剩余内存的时候，抛出OOM）
3. 运行时常量池溢出
4. 方法区溢出（很多框架在运行过程中都会动态生成类，因此也存在OOM的风险）

### 为什么会出现线程安全问题

多线程下出现线程安全问题，就是存在多条线程操作共享资源，CPU在执行时将主内存中的数据拷贝一份作为缓存，之后的操作就可以不再请求主内存拿数据而是从缓存中获取数据，如果执行完成后有更改在刷新到主存，此时如果有多条线程操作，就会出现主内存和缓存中的数据不一致的问题，而导致了最终结果的错误。

多线程对同一个变量做自增，不要用锁？

CAS+volatile（Atomicinteger）

### *如何减少上下文切换次数和时长？*

1. 无锁并发编程
2. CAS算法（java的Atomic包）
3. 使用最少线程（避免创建不必要的线程）
4. 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

### CAS，Compare and Swap

 CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。
 JVM中的CAS操作正是利用了提到的处理器提供的CMPXCHG指令实现的

### 避免死锁的几种常见方法：

1. 避免一个线程同时获取多个锁
2. 避免一个线程在锁内同时占用多个资源，尽量保持每个锁只占用一个资源
3. 尝试使用定时锁（lock.tryLock）
4. 对于数据库锁，加锁和解锁必须在一个数据库链接中。

### 死锁的排查：

- jstack+jps：通过jps确定任务进程号，用jstack查看进程堆栈信息。查看线程所等待的锁。
- jconsole：jconsole连接到任务进程，可以进行死锁检测

排查到造成死锁的线程可以对相关的线程进行终结/休眠

### 死锁的预防：

- 以正确的顺序获得锁
- 超时放弃

### 如何创建线程：

- 继承Thread类，重写run方法
- 实现Runnable接口，重写run方法
- 通过Callable和FutureTask创建创建线程

### 线程的状态

**初始(NEW)**：新建一个线程的对象，还未调用start方法

**运行(RUNNABLE)**：java线程中将已经准备就绪(Ready)和正在运行中(Running)的两种状态都统称为“Runnable”。准备就绪的线程会被放在线程池中等待被调用

**阻塞(BLOCKED)**：是因为某种的原因而放弃了CPU的使用权，暂时的停止了运行。直到线程进入准备就绪(Ready)状态才会有机会转到运行状态

**等待(WAITING)**：该状态的线程需要等待其他线程做出一些特定的动作（通知或者是中断）

**超时等待(TIME_WAITING)**：该状态和上面的等待不同，他可以在指定的时间内自行返回

**终止(TERMINATED)**：线程任务执行完毕

### 线程阻塞

线程阻塞通常是指一个线程在执行过程中暂停，以等待某个条件的触发。而什么情况才会使得线程进入阻塞的状态呢？

- 等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒。唤醒后该线程进入等锁池（同步队列），如果线程重新获得对象的锁就可以进入就绪状态。
- 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“等锁池”中
- 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态

### 三种创建线程方式的对比：

1. 继承Thread创建线程的方式比较简单，但Java是单继承，继承了Thread后就不能继承其他类了。相比之下，实现Runnable和Callable接口的方式还可以继承其他类。
2. 继承Thread时，使用this即可获取当前线程；实现接口的方式则必须使用Thread.currentThread()方法。
3. Callable方式重写的是call方法，Runnable重写的是run方法
4. Callable的任务执行后可以有返回值， 而Runnable的任务是没有返回值的
5. call方法可以抛出异常，run方法不可以

### 如何停止线程？interrupted和isInterrupted的区别

+ stop方法：通过调用Thread对象的stop方法，可以停止相应的线程。但这种方法可能会使数据出错，stop会使锁定的对象解锁，数据可能会出现不一致的情况
+ 用interrupt()方法，这个方法会给相应的线程设置一个停止标记，但这个方法并不会停止线程。需要配合`isInterrupted()`或`interrupted()`使用。在检测到停止标记后，可以**用return或者抛出异常的方法结束run方法**。
  + `interrupted()`，Thread类的静态方法，作用是测试当前线程是否已经中断（也就是停止标记是否为true）。此方法为清除线程的停止状态，也就说如果此方法检测到停止标记为true，则会置为false。但如果为false则还是false
  + `isInterrupted()`，Thread类的普通方法，测试线程对象是否中断。这个方法需要Thread对象调用，但不清除状态标记。这个方法不在Runnable接口中
+ 可以使用退出标志（一般采用boolean变量），这个 flag 变量要多线程可见。终止标记的问题在于其它线程必须可见。

### sleep和wait、yield方法、join方法

+ sleep 方法，是线程类 Thread 的静态方法。调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是**对象的锁依然保持**，因此休眠时间结束后会自动恢复（线程回到就绪状态）
+ wait 方法，是 Object 类的方法。调用对象的wait() 方法，会导致当前线程**放弃对象的锁（线程暂停执行）**，进入对象的等待池（等待队列），只有调用对象的notify() 方法（或#时，才能唤醒等待池中的线程进入等锁池（同步队列），如果线程重新获得对象的锁就可以进入就绪状态。
+ yield方法，静态方法，调用yield表示当前线程将CPU资源让给其它线程，进入可执行状态，但是**不释放锁**，而且有可能执行yield线程立刻又进入运行状态
+ join：a.join() 表示主线程要等待a执行完毕，然后主线程才会执行

### 多线程开发良好的实践

+ 给线程命名
+ 最小化同步范围
+ 优先使用 volatile ，而不是 synchronized
+ 尽可能使用更高层次的并发工具而非 wait 和 notify 方法来实现线程通信
+ 优先使用并发容器，而非同步容器

### Synchronized实现原理，以及JVM对锁性能的优化

##### Synchronized作用？实现？

Synchronized可以保证发方法或者代码块在运行时，同一时刻只有一个 进程可以进入到临界区，同时它还可以保证共享变量的内存可见性

##### synchronized关键字最主要的三种使用方式：

- 修饰实例方法，作用于当前对象的实例加锁，进入同步代码前要获得当前对象实例的锁
- 修饰静态方法，作用域当前类对象加锁，进入同步代码前要获得当前类对象的锁，也就是当前类的Class对象的锁。如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，因为访问静态synchrnoized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例的锁。
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

##### synchronized如何实现的：

- 同步块

  synchrnoized同步块的实现是使用monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块开始的位置，monitorexit指令指向同步代码块结束的位置。当执行monitorenter指令时，线程获取锁也就是获取monitor对象（monitor对象存在于每个Java对象的对象头中）

- synchronized方法

  synchronized修饰的方法并没有monitorenter和monitorexit指令，取而代之的是ACC_SYNCHRONIZED（被标记在方法表的访问标志中）JVM通过该标志来判断一个方法是否被声明为同步方法。

  如果方法是同步方法，则执行线程将先持有monitor，在执行方法，最后方法完成（无论是正常完成还是非正常完成）时释放monitor。在方法执行期间，执行线程持有了这个monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且再方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。

synchorized用的锁是存在Java对象头里面的。对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，如：如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等

非数组类型对象对象头为2字宽，第一字宽为标记字段，第二字宽为类型指针，数组类型有第3字宽表数组长度。（一字宽等于四字节）

Mark Word的默认状态为无锁态，运行期间Mark Word里存储的数据会随着锁标志的变化而变化。

Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是互斥和信号机制

* 互斥：一个Monitor锁在同一时刻只能被一个线程占用，其他线程无法占用
* 信号机制(signal)： 占用Monitor锁失败的线程会暂时放弃竞争并等待某个谓词成真（条件变量），但该条件成立后，当前线程会通过释放锁通知正在等待这个条件变量的其他线程，让其可以重新竞争锁

每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用，Nest字段用来实现重入锁的计数。

##### Synchronized支持重入有什么好处？

可重入锁又名递归锁，是指在同一个线程的外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提是锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和Synchronized都是可重入锁

重入锁的一个优点是可一定程度避免死锁

##### 虚拟机对Synchronized关键字底层做了哪些优化

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

重量级锁是要使用系统级别的线程操作，线程如果没有获得锁会进入阻塞状态，这样线程调度时会比较消耗时间，所以是重量级锁。

1. 偏向锁：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价
   引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。当一个线程访问同步块并获取锁时，会在对象头和栈帧程度锁记录中存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁，如果测试失败，需要在测试一下Mark Word中偏向锁的标识是否为1：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

   偏向锁提高有同步但无竞争的程序性能。偏向锁偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。当有另外一个线程尝试获取锁时，偏向模式就会结束。
   倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，而是先升级为轻量级锁

2. 轻量级锁

   轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。轻量级锁的加锁和解锁都用到了CAS操作
   轻量级锁的使用原因是对于绝大部分锁，在整个同步周期内都是不存在竞争的，如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢。如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁。

3. 自旋锁：轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，会进行自旋锁。互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。所以线程获得锁失败后并不会立即阻塞，而是执行一个忙循环（自旋），如果在这期间获得了锁就可以继续执行。但自旋并不能代替阻塞，因为自旋会消耗CPU时间的。

4. 自适应自旋:指自旋时间不固定的锁。自旋时间由前一次的自旋时间和锁的拥有者的状态决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要获得这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

5. 锁消除，指虚拟机即时编译器在运行时，有些代码需要同步，但不可能存在共享资源竞争的锁进行消除。锁消除涉及到逃逸分析（也就是分析一个变量是否为会逃出某一作用域）

6. 锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁

### 偏向锁、轻量级锁的实现

**获取偏向锁**:

1. 检测 Mark Word是 否为可偏向状态，即是否为偏向锁的标识位为 1 ，锁标识位为 01 。
2. 若为可偏向状态，则测试线程 ID 是否为当前线程 ID ？如果是，则执行步骤（5）；否则，执行步骤（3）。
3. 如果线程 ID 不为当前线程 ID ，则通过 CAS 操作竞争锁。竞争成功，则将 Mark Word 的线程 ID 替换为当前线程 ID ，则执行步骤（5）；否则，执行线程（4）。
4. 通过 CAS 竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块。
5. 执行同步代码块

**撤销偏向锁**:

要等待全局安全点

+ 首先会暂停拥有偏向锁的线程并检查该线程是否存活：

  + 如果线程非活动状态，则将对象头设置为无锁状态（其他线程会重新获取该偏向锁）。
  + 如果线程是活动状态，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，并将对栈中的锁记录和对象头的 MarkWord 进行重置：

    + 要么重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)
    + 要么恢复到无锁或者标记锁对象不适合作为偏向锁(此时锁会被升级为轻量级锁)
+ 最后唤醒暂停的线程，被阻塞在安全点的线程继续往下执行同步代码块

### 轻量级锁的获取：

1. 判断当前对象是否处于无锁状态，若是，则JVM首先在当前线程的栈帧中，建立一个名为锁记录（Lock Record）的空间，用于存储锁对象的Mark Word的拷贝（官方称为Displaced Mark Word）；否则，执行3
2. JVM采用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果成功，表示竞争到锁，则将锁标志为变成00（表示此对象处于轻量级锁状态），执行不同操作；如果失败，则执行3
3. 判断当前对象的Mark Word是否指向当前线程的栈帧？如果是，则表示当前线程已经持有当前对象的锁，直接执行同步代码块；否则，只能说明该锁对象已经被其他线程抢占了，当前线程便尝试使用自旋来获取锁。若自旋后没有获得锁，此时轻量级锁会升级为重量级锁，锁标志为变成10，当前线程会被阻塞。

### 轻量级锁解锁:

- 解锁时使用CAS操作将Displaced Mark Word替换回到对象头
- 如果解锁成功，则表明没有竞争发生
- 如果解锁失败，表示当前锁存在竞争，锁会膨胀成重量级锁，需要在释放锁的同时唤醒被阻塞的线程，之后线程间要根据重量级锁规则重新竞争重量级锁

### happens-before 原则是什么？

Happens-Before原则：保证哪些不能进行指令重排，是JMM为了保证原子性、可见性以及有序性的辅助手段

+ 程序顺序原则：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行
+ volatile原则：volatile变量的写先于读。也就是volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值
+ 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)
+ 传递性：A先B,B 先于C，则A一定先于C
+ 线程启动规则：线程的start先于其它动作
+ 线程终止规则：线程的所有操作先于线程的终结
+ 线程中断规则：线程的中断先于被中断线程的代码
+ 对象终结规则：对象的构造函数执行、结束先于finalize

这8条规则是不需要任何同步手段就可以达到的。如果代码不适用于上述8条原则中的一条，也没有用同步手段，操作就是线程不安全的

什么是JMM？

JMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果

### JMM和Java内存区域划分区别

JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开的。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈

### volatile的作用？volatile是如何实现?单例模式双重检查(DCL)为什么要用volatile

**volatile关键字有两个作用**：

+ 保证被volatile修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。

+ 禁止指令重排序优化。

**如何实现的**

当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。volatile变量正是通过这种写-读方式实现对其他线程可见。其内存语义实现则是通过内存屏障。有序性则是Java内存模型中的happen-before原则保证的

内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本

**DCL为什么需要volatile**:

volatile的典型应用就是单例模式中的DCL（双重检验）。DCL中使用volatile的原因在实例化对象主要包括分配内存空间->初始化对象->将内存空间的地址赋值给对象的引用这三个步骤，而初始化对象和将内存空间的地址赋值给对象的引用这两步可能发生重排，这时，就可能发生一个线程在仅赋值给引用而没有初始化时，这个对象的引用就被另一个线程使用。

```Java
// 双重检验
public class LazySingleton {
    private static volatile LazySingleton INSTANCE;
    private LazySingleton() {}
    public static LazySingleton getInstance() {
        if (INSTANCE == null) {
            synchronized (LazySingleton.class) {
                if (INSTANCE == null)
                    INSTANCE = new LazySingleton();
            }
        }
        return INSTANCE;
    }
}
```

使用volatile的条件：

* 对变量的写操作不依赖于当前值。
* 该变量没有包含在具有其他变量的不变式中。

**区别**：

1. volatile仅能使用在变量级别；synchronized则可以使用在代码块、方法、和类级别的
2. volatile仅能实现可见性，并不能保证原子性；synchronized则可以保证可见性、原子性和有序性
3. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞
4. volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

### 队列同步器AQS

AbstractQueuedSynchronizer又称为队列同步器(后面简称AQS)，是用来构建锁或其他同步组件的基础框架。

AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

AQS使用一个int成员变量state来表示同步状态，,当state=0时，则说明没有任何线程占有共享资源的锁，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。

```java
private volatile int state;//共享变量，使用volatile修饰保证线程可见性
```

在 AQS 内部，通过维护一个FIFO 队列（CLH队列）来管理多线程的排队工作。在公平竞争的情况下，无法获取同步状态的线程将会被封装成一个节点，置于队列尾部（入队的过程采用的是CAS）。入队的线程将会通过自旋的方式获取同步状态，若在有限次的尝试后，仍未获取成功，线程则会被阻塞住。大致示意图如下：

![AQS](F:\mycode\knowledgeArrangement\java开发\AQS.jpg)

当头结点释放同步状态后，且后继节点对应的线程被阻塞，此时头结点线程将会去唤醒后继节点线程。后继节点线程恢复运行并获取同步状态后，会将旧的头结点从队列中移除，并将自己设为头结点。

![AQS](F:\mycode\knowledgeArrangement\java开发\AQS2.jpg)

在并发的情况下，AQS 会将未获取同步状态的线程将会封装成节点，并将其放入同步队列尾部。同步队列中的节点除了要保存线程，还要保存等待状态。不管是独占式还是共享式，在获取状态失败时都会用到节点类

在AQS中资源共享方式主要有两种：

+ Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：
  + 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  + 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
+ Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。

独占式获取同步状态：

+ 调用 tryAcquire 方法尝试获取同步状态
+ 获取成功，直接返回
+ 获取失败，将线程封装到节点中，并将节点入队
+ 入队节点在 acquireQueued 方法中自旋获取同步状态
+ 若节点的前驱节点是头节点，则再次调用 tryAcquire 尝试获取同步状态
+ 获取成功，当前节点将自己设为头节点并返回
+ 获取失败，可能再次尝试，也可能会被阻塞。这里简单认为会被阻塞。

共享模式获取同步状态

+ 获取共享同步状态
+ 若获取失败，则生成节点，并入队
+ 如果前驱为头结点，再次尝试获取共享同步状态
+ 获取成功则将自己设为头结点，如果后继节点是共享类型的，则唤醒
+ 若失败，将节点状态设为 SIGNAL，再次尝试。若再次失败，线程进入等待状态

### ReentrantLock如何实现的

首先ReentrantLock是独占锁，ReentrantLock底层是AQS。ReentrantLock的内部类Sync继承了AQS，另外两个内部类NonfairSync、FairSync继承了Sync类，分别表示非公平锁和公平锁的实现（tryAcquire()方法）。ReentrantLock的所有方法调用都通过间接调用AQS和Sync类及其子类来完成的。

本质上仍然是是利用CAS+CLH队列实现，获取锁的时候先通过CAS尝试获取锁。若获取失败则将当前线程封装为Node节点加入CLH队列自旋后（自旋一次后会阻塞）。当锁释放时会唤醒CLH队列中的次节点，然后CAS再次尝试获取锁。

### 可重入锁的实现原理

每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。

### ReentrantLock的公平锁和非公平锁体现在哪里

在ReentrantLock内部公平锁的实现就是FairSync，非公平锁的实现就是NoFairSync。
这两种锁的方式都是lock方法，区别如下：

* 非公平锁在lock方法中会先进行一次CAS操作，若获取失败，调用AQS的acquire方法，然后回调子类Sync的nonfairTryAcquire方法，而在该方法中判断当前锁状态为0时也会直接利用CAS抢锁
* 公平锁是通过AQS的acquire方法回调子类的tryAcquire方法（不像非公平锁会先进行CAS操作），方法中如遇到所状态为0，会先判断当前线程是否为同步队列的第一个节点，如果是才会通过CAS来获取同步状态

```Java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    // 获取state变量
    int c = getState();
    // state为0表示没有线程持有锁，可以尝试获取
    if (c == 0) {
        // 公平锁会先判断当前同步队列的是否有线程在排队，若无则通过CAS尝试获取
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            // 获取锁成功 设置当前线程为执行线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 重入锁逻辑，判断持有锁的线程是否为当前线程，如果是累加state变量
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    // 获取锁失败 后序AQS会将这个线程放进同步队列，并挂起
    return false;
}
```

总的来说就是：公平锁会先判断当前同步队列是否有线程在等待，有则进入同步队列排队若没有才尝试尝试获取锁。而非公平锁不管队列中是否有线程在排队，多次直接尝试获取锁。

### 非公平锁为什么效率高

在公平锁下，当一个线程请求锁时，即使锁空闲也要先检查队列中是否有线程在等待，如果有则要将当前节点加入等待队列并挂起，然后唤醒队列最前面的线程。这种情况下比较非公平锁多了一次挂起和唤醒（每次请求锁）。

总的来说，公平锁比非公平锁多出的开销就是线程的阻塞和唤醒。

公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

### ReetrantLock和synchronized有什么区别

* ReenTrantLock 比synchronized提供了更多，更全面的功能，例如：定时锁、可中断锁
* ReentrantLock提供了条件Condition，对线程的等待、唤醒操作更加灵活。在多个条件变量和高度竞争锁的地方ReentrantLock更加合适
* ReentrantLock提供了可轮询的锁请求（tryAcquire）。它会尝试获取锁，如果成功则继续，否则可以等到下次运行时处理。而synchorized则一旦请求锁，要么成功要么阻塞，所以相较于ReentrantLock，synchorized更易死锁
* ReentrantLock支持公平锁和非公平锁，而synchorized只支持非公平锁
* synchronized 依赖于 JVM 而 ReenTrantLock 依赖于AQS实现

### Lock接口提供的而synchronized不具备的特性：

* 可轮询锁
* 中断锁
* 定时锁

### 读写锁ReadWriteLock的使用

读写锁是读读不互斥，读写互斥，写写互斥，适用于读远远大于写的场景

在Java中ReadWriteLock的主要实现为ReentrantReadWriteLock

读写锁的特点：

+ 公平性选择：支持公平与非公平（默认）的锁获取方式，吞吐量非公平优先于公平。
+ 可重入：读线程获取读锁之后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁
+ 可降级：写线程获取写锁之后，其还可以再次获取读锁，然后释放掉写锁，那么此时该线程是读锁状态，也就是降级操作。
+ 中断锁的获取：在读锁和写锁获取过程中支持中断。
+ 支持Condition
+ 监控：提供锁是否被持有的辅助方法

原理：

读写锁的核心是由一个基于AQS队列同步器Sync构成，然后扩展出ReadLock（共享锁），WriteLock（排它锁）

在获取读写状态时，把state（int32位）字段分成高16位与低16位，其中高16位表示读锁个数，低16位表示写锁个数

读锁的获取：

操作1：读写需要互斥，因此当存在写锁并且持有写锁的线程不是该线程时获取失败。
操作2：是否存在等待写锁的线程，存在的话则获取读锁需要等待，避免写锁饥饿。(写锁优先级是比较高的)
操作3：CAS获取读锁，实际上是state字段的高16位自增。
操作4：获取成功后再ThreadLocal中记录当前线程获取读锁的次数。

如果操作2和操作3失败会进行循环获取锁：

操作5：等同于操作2，存在写锁，且写锁线程并非当前线程则直接返回失败
操作6：当前线程是重入读锁，这里只会偏向第一个获取读锁的线程以及最后一个获取读锁的线程，其他都需要去AQS中排队。
操作7：CAS改变读锁状态
操作8：同操作4，获取成功后再ThreadLocal中记录当前线程获取读锁的次数。

写锁的获取：

操作1：如果读锁数量不为0或者写锁数量不为0，并且不是重入操作，则获取失败。
操作2：如果当前锁的数量为0，也就是不存在操作1的情况，那么该线程是有资格获取到写锁，因此修改状态，设置独占线程为当前线程

### LockSupport(park/unpark)

归根结底，LockSupport.park()和LockSupport.unpark(Thread thread)调用的是Unsafe中的native代码：

```Java
//LockSupport中
public static void park() {
    UNSAFE.park(false, 0L);
}

//LockSupport中
public static void unpark(Thread thread) {
    if (thread != null)
        UNSAFE.unpark(thread);
}
```

park函数是将当前调用Thread阻塞，而unpark函数则是将指定线程Thread唤醒。

park/unpark有两个优点：**

- 以thread为操作对象更符合阻塞线程的直观定义
- 操作更精准，可以准确地**许可**某一个线程（notify随机唤醒一个线程，notifyAll唤醒所有等待的线程），增加了灵活性。

**park是等待一个许可，unpark是为某线程提供一个许可。**

如果某线程A调用park，那么除非另外一个线程调用unpark(A)给A一个许可，否则线程A将阻塞在park操作上。

**有一点比较难理解的，是unpark操作可以再park操作之前。**
也就是说，先提供许可。当某线程调用park时，已经有许可了，它就消费这个许可，然后可以继续运行。这其实是必须的。

**但是这个“许可”是不能叠加的，“许可”是一次性的。**
比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态

### InterruptedException异常

当阻塞方法收到中断请求的时候就会抛出InterruptedException异常

每一个线程都有一个boolean类型的标志，此标志意思是当前的请求是否请求中断，默认为false。当一个线程A调用了线程B的interrupt方法时，那么线程B的是否请求的中断标志变为true。而线程B可以调用方法检测到此标志的变化。

1. 阻塞方法：如果线程B调用了阻塞方法，如果是否请求中断标志变为了true，那么它会抛出InterruptedException异常。**抛出异常的同时它会将线程B的是否请求中断标志置为false**
2. 非阻塞方法：可以通过线程B的isInterrupted方法进行检测是否请求中断标志为true还是false，另外还有一个静态的方法interrupted方法也可以检测标志。但是静态方法它检测完以后会自动的将是否请求中断标志位置为false。例如线程A调用了线程B的interrupt的方法，那么如果此时线程B中用静态interrupted方法进行检测标志位的变化的话，那么第一次为true，第二次就为false。

现在知道线程可以检测到自身的标志位的变化，但是他只是一个标志，如果线程本身不处理的话，那么程序还是会执行下去。

因此interrupt() 方法并不能立即中断线程，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于线程自己

有时候阻塞的方法抛出InterruptedException异常并不合适，例如在Runnable中调用了可中断的方法，因为你的程序是实现了Runnable接口，然后在重写Runnable接口的run方法的时候，那么子类抛出的异常要小于等于父类的异常。而在Runnable中run方法是没有抛异常的。**所以此时是不能抛出InterruptedException异常**。如果此时你只是记录日志的话，那么就是一个不负责任的做法，因为在捕获InterruptedException异常的时候自动的将是否请求中断标志置为了false。至少在捕获了InterruptedException异常之后，**如果你什么也不想做，那么就将标志重新置为true，以便栈中更高层的代码能知道中断，并且对中断作出响应。**