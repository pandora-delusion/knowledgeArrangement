[TOC]

# 计算机网络

## 网络体系结构

+ OSI七层体系结构:
+ TCP/IP四层体系结构：事实上的标准
+ 五层体系结构仅用于研究，没有实际意义

![网络体系结构](F:/mycode/知识点整理/pics/网络体系结构.png)

### OSI七层体系结构

+ 应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用
+ 表示层（数据）：主要解决用户信息的语法表示问题，如加密解密
+ 会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机 制，如服务器验证用户登录便是由会话层完成的
+ 传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠
  与不可靠的传输，传输层的错误检测，流量控制等
+ 网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输
+ 数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正
+ 物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等

### 五层体系结构（熟悉）

+ 应用层：用于应用进程间的交互
+ 运输层：提供不同主机上用户进程之间的逻辑通信，可靠与不可靠的传输，传输层的错误检测，流量控制等
+ 网络层：提供不同主机间的逻辑通信，数据从源端到目的端的传输
+ 数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正
+ 物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等

### TCP/IP 四层体系结构

+ 应用层：HTTP、DNS、TELNET、FTP、SMTP、POP3。其中除了DNS，其它的运输层都是用TCP协议
+ 传输层：TCP、UDP
+ 网络层：IP、ICMP
+ 网络接口层：PPP

### 数据交换设备所处的层（了解）

+ 网关：应用层、传输层
+ **路由器**：网络层。路由选择、存储转发
+ **交换机**：数据链路层
+ 网桥：数据链路层
+ 集线器（Hub）：物理层
+ 中继器：物理层

## TCP/IP协议

### TCP的三次握手过程，为什么需要三次握手

**三次握手过程**：

![三次握手](F:/mycode/知识点整理/pics/三次握手.png)

下面的ACK表示标志位，ack指确认号

+ 客户端:向服务端发送带有 SYN=1，ACK=0，seq=x的数据包，选择一个初始的序号 x，**第一次握手**
+ 服务端：向客户端发送SYN=1，ACK=1，ack=x+1，seq=y的数据包，确认号为 x+1，选择一个初始的序号 y，**第二次握手**
+ 客户端：向服务端发送ACK=1的数据据包，确认号为 y+1，序号为 x+1

**为什么要三次握手**：

三次握手的目的是建立可靠的通信信道，通讯简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常

所以三次握手就能确认双方收发功能都正常，缺一不可。

如果只有两步是无法确定客户端是否能够正常接收，同时可能无法就Server的初始序号达成一致

第2步是为了Server向Client表示已经收到了Client的握手信号，同时也是为了向Client发送握手信号，并发送Server的初始序号。

第3步是为了表示Client的接收到了Server的握手信息

**补充内容**：A表示Client，B表示Server

+ 第一个包，即A发给B的SYN 中途被丢，没有到达B。A会周期性超时重传，直到收到B的确认
+ 第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A。B会周期性超时重传，直到收到A的确认
+ 第三个包，即A发给B的ACK 中途被丢，没有到达B。A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：
  + 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。
  + 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的 Data。
  + 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。

参考：

+ <https://www.zhihu.com/question/24853633/answer/115173386>

### TCP为什么要三次握手？两次为什么不可以

TCP三次握手是为了能够可靠传输而对某些问题达成一致(主要就是序号)。

三次是为了防止已失效的连接请求报文突然又传送到了服务端，因而产生错误。

如果只有两次，有已失效的连接请求到达服务端，服务端会在发出确定数据包就会建立连接，但此时客户端并没有发出建立连接的请求，因为服务端接收到的请求是失效的。客户端不会响应Server的确认，不会向Server发送数据。而此时Server一直在等待客户端的数据，这样Server就浪费了一定的资源。

根据知乎上的回答，三次握手是为了约定确定双方的 ISN（初始的序列号），第三次是为了确认服务端的序号

所以**第三次是为了防止服务器端的一直等待而浪费资源**

### TCP初始序号随机的原因

1. 让攻击者更难以猜测sequence number，因为伪造的sequence number不在合法范围内，而被接收方丢弃，增加安全性、
2. 减少将网络中存在的原连接的报文段误认为是新连接报文段的可能性（碰巧新旧连接使用了相同的端口号）

### 如果客户端一直发送连接的请求怎么办？SYN攻击

服务端在收到客户端请求后，向客户端发送确认，然后会等待客户端的确认。如果客户端一直不确认，会造成大量的半连接，这就是**SYN攻击**

1. 客户端向服务端发送请求连接数据包。
2. 服务端向客户端发送确认数据包。
3. 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击

解决：

+ 限制同时打开 SYN 半链接的数目
+ 缩短 SYN 半链接的 Timeout 时间
+ 关闭不必要的服务。
+ 增加最大半连接数
+ SYN cookie 技术

### TCP的四次挥手的过程，为什么要4次挥手

![四次挥手](F:/mycode/知识点整理/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

主动断开的一方：主动关闭方（A），另一方是被动关闭方（B）

+ A向B发送一个FIN，并且序号为u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时表示A不再向B发送数据包
+ B收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1,同时带上序号为v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。此步仅仅是为了向A告知B已经知道了断开连接的请求。B此时可能还需要处理A请求断开之前的数据包，也可能向A发送数据
+ A收到B的确认请求后，此时，A就进入FIN-WAIT-2（终止等待2）状态，等待B发送连接释放报文
+ B在处理完数据报文后，便发送给主动方FIN报文。并且序号为w，ack为u+1.这一步的目的是为了告诉A已经处理完断开之前的数据报。
+ A发送ACK，确认已经收到B的FIN报文，确认序号为w+1。此时，A就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当A撤销相应的TCB后，才进入CLOSED状态
+ B只要收到了客户端发出的确认，立即进入CLOSED状态

### 为什么主动断开的一方在确认被动方的断开请求后，需要等待2MSL

也就是TIME-WAIT状态

如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的 TCP 报文可能与新 TCP 连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的 TCP 连接的活跃报文全部消失。

**另一个原因**：无法保证主动方的ACK一定会被接收到，所以被动方可能会重传FIN报文

### `Close_Wait`或`Time_Wait`状态的连接过多怎么办

### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

关闭连接多一次的原因是服务端在收到客端的请求后，仅仅表明客户端不再发送新的数据，而服务端可能还要处理数据，所以服务端需要在处理完发送一次请求断开的连接

<https://www.cnblogs.com/mfmdaoyou/p/6715422.html>

### TCP拥塞控制

拥塞控制就是防止过多的数据注入到网络中，这样可以防止网络中的路由器或链路不致过载

![拥塞控制1](F:/mycode/知识点整理/pics/TCP.png)

+ 慢开始
  拥塞窗口（cwnd）是指发送方维护的一个根据网络状况动态变化的窗口。一般来说，发送方会让自己的发送窗口等于拥塞窗口的大小。
+ 拥塞避免：达到ssthresh，这个值一般要根据之前的拥塞得到的。让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1
+ 快重传，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段
+ 快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法

### TCP流量控制：滑动窗口

滑动窗口协议，是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。

TCP 的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。

### TCP 协议如何保证可靠传输

+ 应用数据被分割成 TCP 认为最适合发送的数据块。
+ TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
+ 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
+ 接收端会对发送的数据进行确认
+ TCP 的接收端会丢弃重复的数据。
+ 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
+ 拥塞控制： 当网络拥塞时，减少数据的发送。
+ 停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### TCP、UDP协议的区别

UDP提供无连接不可靠的数据传输服务。UDP 在传送数据之前不需要先建立连接，主机在收到 UDP 报文后，不需要给出任何确认。UDP 不提供可靠交付，但在某些情况下 UDP 效率更高。

TCP 提供面向连接可靠的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务，增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

### TCP面向字节流、UDP面向报文

UDP面向报文指的是对于应用层交给UDP的报文，UDP原样发送，一次发送一个报文。保留报文的边界，不会对报文进行拆分和合并。

TCP面向字节流指的是TCP会将应用层交付的数据块看成一连串无结构的字节流。TCP中存在缓冲，会对数据块进行合并和拆分。

### UDP的主要特点

+ UDP 是无连接的；
+ UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
+ UDP 是面向报文的；
+ UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；
+ UDP 支持一对一、一对多、多对一和多对多的交互通信；
+ UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

### TCP的主要特点

+ TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
+ 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
+ TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
+ TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
+ 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

### 可靠传输原理，并设计可靠 UDP 协议。

+ 停止等待协议：“停止等待”就是每发送完一个分组就停止发送，等待对方确认。在手动确认后再发送下一个分组。
  利用确认和重传机制，就可以在不可靠的传输网络上实现可靠的通信。 
  像上述的这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat Request)。意思是重传的请求时自动进行的。接收方不需要请求发送方重传某个出错的分组。
+ 可靠的UDP协议
  1、添加seq/ack机制，确保数据发送到对端。
  2、添加发送和接收缓冲区，主要是用户超时重传。
  3、添加超时重传机制。
  1)、发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。
  2)、时间到后，定时任务检查是否需要重传数据。

## DNS

### DNS使用的协议，DNS解析域名的顺序

协议：既使用 TCP 又使用 UDP

+ 辅域名服务器会定时（一般时 3 小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用 TCP 而不是 UDP ，因为数据同步传送的数据量比一个请求和应答的数据量要多得多
+ 域名解析时使用 UDP 协议。

主要还是UDP协议

**解析顺序**：

+ 浏览器缓存
+ 找本机的 hosts 文件
+ 路由缓存
+ 找 DNS 服务器(本地域名、顶级域名、根域名)

迭代查询：当查不到时，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址

递归查询：该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机

## HTTP

### 在浏览器中输入url地址->>显示主页的过程

+ DNS解析：通过域名找出IP地址
+ TCP连接
+ 发送HTTP请求
+ 服务器处理请求并返回HTTP报文
+ 浏览器解析渲染页面
+ 连接结束

https://segmentfault.com/a/1190000006879700

### HTTP和HTTPS的区别

HTTP（超文本传输协议）是用网络链接传输文本信息的协议
HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层。

两者的区别：

* HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
* HTTP 是不安全的，而 HTTPS 是安全的
* HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
* 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层​
* http无需证书，https协议需要到ca申请SSL证书
* http信息明文传输，https对数据进行加密

### HTTPS是如何实现的

核心是SSL/TLS。在传输层和应用层之间加了一层SSL/TLS。

SSL(Secure Socket Layer，安全套接字层)：分为SSL握手协议（传输前的认证，交换密钥等）和SSL记录协议（提供数据封装、加密等）。

TLS：传输层安全协议。TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）

TLS是SSL的加强版，同一个东西的不同版本

HTTPS涉及的概念：

+ 公钥（Public Key）与私钥（Private Key）是通过一种算法得到的一个密钥对（即一个公钥和一个私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。
+ 对称密钥加密（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。如AES等。对称加密加密和解密更快
+ 非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如RSA、DH算法

HTTPS=数据加密+网站认证+完整性验证+HTTP

证书是为了防止中间人攻击，替换传输的公钥

### https连接建立过程

* 客户端发送请求到服务端
* 服务端返回公钥和证书到客户端
* 客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端
* 服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密
* 客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户
* SSL加密建立
  ![](F:/mycode/知识点整理/assets/627325-dc83fef6ac2e6c88.webp)
  参考：<https://www.zhihu.com/question/52493697/answer/130813213>

### HTTP长连接、短连接

+ 实质上是TCP协议的长连接和短连接。

>短连接的操作步骤是：
>建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接

>长连接的操作步骤是：
>建立连接——数据传输...（保持连接）...数据传输——关闭连接

长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket创建也是对资源的浪费。

而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下用短连接。

### 常见的HTTP方法

* GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
* POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
* PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
* HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
* DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
* OPTIONS：查询相应URI支持的HTTP方法。

### 常见的HTTP状态码

返回的状态
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求

* 200：请求被正常处理
* 204：请求被受理但没有资源可以返回
* 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
* 301：永久性重定向
* 302：临时重定向
* 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
* 304：发送附带条件的请求时，条件不满足时返回，与重定向无关
* 307：临时重定向，与302类似，只是强制要求使用POST方法
* 400：请求报文语法有误，服务器无法识别
* 401：请求需要认证
* 403：请求的对应资源禁止被访问
* 404：服务器无法找到对应资源
* 500：服务器内部错误
* 503：服务器正忙

### get和post的区别(作用、参数、安全性、幂等性、可缓存)

1. get一般用于获取资源，而post用于上传资源
2. get的参数通过？&的方式接在URL中并且有长度限制，post的参数在请求的body中且无长度限制
3. get的参数在URL中明文传输不安全，post放在body比get安全
4. get满足幂等性，post不满足，每次造成的副作用不一定相同
5. get请求可​缓存，post请求不可缓存

### 幂等性是什么

数学上;f(x)=f(f(x)) 能够成立的数学性质

程序上：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的

程序中实现幂等性：

1. MVCC
2. 去重表：即利用表的唯一索引，在操作时只插入不修改，一个索引只写入一次
3. TOKEN机制：一次操作有一个唯一的token，一个token只有一次执行权。比如订单id作为token

### http1.0/http1.1/http2.0 的区别

1. http1.0默认短链接，若要使用长连接需要设置connection：keep-alive。而http1.1 默认使用长连接。因为http通讯是需要三次握手，建立连接有开销，使用长连接可以减少开销
2. http1.1支持只发送head，当返回100的时候再发送body，若返回401则可以不继续发送body，从而减少带宽
3. http1.1支持部分内容传送，即断点续传。
4. http1.1有host属性，http1.0没有 即支持虚拟站点 host

Http2.0特性：

1. http2.0 可以实现一个连接并发处理多个请求，即多路复用，减少对连接的建立时的开销。多个HTTP流使用同一个TCP连接，遵守同一个流量状态控制。只要第一个HTTP流遭遇到拥塞，剩下的HTTP流压根没法发出去，头部阻塞
2. 数据压缩，head压缩
3. 服务器推送，http2.0会将一些需要的数据返回给客户端，减少访问

HTTP 3.0 基于QUIC协议，UDP

### HTTP 与 FTP 的比较

FTP和HTTP一样都是Internet上广泛使用的协议，用来在两台计算机之间互相传送文件。相比于HTTP，FTP协议要复杂得多。复杂的原因，是因为FTP协议要用到两个TCP连接，一个是命令链路，用来在FTP客户端与服务器之间传递命令；另一个是数据链路，用来上传或下载数据。

## Cookie和Session

### 什么是Cookie和Session

Cookie在服务端生成，存在客户端。客户端访问某个地址时，服务器会根据页面的头部信息生成coolkie（字符串），然后cookie会加在http响应头中，发往客户端并保存在浏览器。在下次客户端请求时，请求中会附带存储的Cookie。

Session 是在服务器端生成的，存储在服务器端，即存在内存中。可以对生成的 Session 设置过期时间，如果不设置过期时间，默认的 Session 过期时间是30 分钟。但是，Sesssion 的生成的同时，会生成一个与之相关联的的 SessionID ，此SessionID的存储是需要 Cookie来完成的。SessionID 是以名称为 JSESSIONID，其值应该是一个既不会重复，又不容易被找到规律以仿造的字符串。SessionID会随着此次Http响应，一并返回到客户端，并保存在客户端中(Cookie)。到当前请求再次发出后，该 SessionID会随着 Http 头部，传到服务器中，服务器依据当前 SessionID 得到与之对应的 Session.

注意：一个域，在客户端建立的所有的Cookie都是可以共享的，只要 Cookie 没有过期。

### 为什么需要cookie和Seesion

在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。Cookie和Session的出现就是为了解决这个问题。

* Cookie使用场景：有些网站有记住用户名的功能，当你勾这个的时候，下次进入该网站时，就会保存上一次登录的用户名
* Seesion使用场景：利用Seesion来验证用户是否已登录，利用Session来保存验证码。

### Cookie和Session的区别

* Cookie是存在客户端，Session存在服务器
* 安全性要求高的用Session，要求低用Cookie
* Cookie只能存储字符串，Session可以存储任何信息
* Cookie如果不设置时间，当关闭浏览器时，Cookie就失效，不会在本地保存；Session的生命周期是一个会话（当启动浏览器到关闭浏览器）
* 在存储相对持久的信息时，应考虑使用 Cookie，因为 Cookie 可以以文件的形式，存储在客户端。在进行一些登录的验证及信息拦截的时候，可以使用 Session。

https://blog.csdn.net/liyifan687/article/details/80077928

参见：https://www.cnblogs.com/xiaoshitoutest/p/6103790.html

### cookie和session结合使用

web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1. 存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。
2. 将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。

参见博客：https://www.cnblogs.com/xxtalhr/p/9053906.html

### 如何客户端禁用了Cookie，如何存储用户的信息

如果客户端禁用了 Cookie 的话，很多网站任然可以存储用户的信息。一种处理的方式是URL 重写，将 SesseionID 直接附加在请求地址的后面。另一种处理的方式是，使用隐藏自动的方式。就是服务器自动的在表单中，添加一个隐藏字段，以便在表单提交时，将 SesseionID 一起传到服务器，进行识别。

### Session的问题

* session是存在服务器的内存中的，如果session过多会影响服务器的性能
* session只在一台服务器里，当有多台服务器的时候，访问别的服务器肯定会失败（需考虑Session共享）

### Cookie的安全问题

1. 对保存到cookie里面的敏感信息必须加密
2. 设置HttpOnly为true 该属性值的作用就是防止Cookie值被页面脚本读取。
3. 设置Secure为true，只有在https协议下访问的时候，浏览器才会发送该Cookie
4. 给Cookie设置有效期